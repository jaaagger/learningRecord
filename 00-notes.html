<!DOCTYPE html>
<html>
<head>
	<title>notes</title>
	<style type="text/css">
		a{
			display: block
		}
	</style>
</head>
<body>
	<a href="https://juejin.im/entry/5aee8fbb518825671952308c">
		Vue生命周期
	</a>
	<a href="https://segmentfault.com/a/1190000018689948">
		小程序面试题
	</a>
	<script type="text/javascript">
		// style
		// 1.只能获取内联样式
		// 2.可以赋值修改

		// offset
		// 1.父元素必须有定位
		// 2.包含padding,content,border
		// 3.offsetWidth不能被赋值，只能被获取

		// client
		// 1.包含padding,content

		// scroll
		// 1.包含content,padding
		// 2.与client不同：client内容超出时还是原来高度，scroll为超出的内容大小
		// 3.scrollTop包括被卷去的高度



		// mouseover
		// 1.鼠标经过父盒子，子盒子都会触发
		// 2.子盒子不冒泡给父盒子

		// mouseenter,mouseleave
		// 1.鼠标经过子盒子不会触发
		// 2.子盒子不会冒泡给父盒子，因此父盒子不会再次冒泡



		// js动画函数的封装
		// 1.setInterval改变元素位置
		// 2.元素必须添加定位



		// W3C标准是浏览器标准，规定WebAPI：浏览器提供操作BOM,DOM元素的接口
		// ECMAScript是JS标准，规定标准的JS语法
		// DOM：文档对象模型，W3C标准，处理可扩展语言的标准编程接口
		// DOM树：由文档、元素、节点组成，都称为对象
		// 文档：一个页面就是一个文档，document表示
		// 根元素：html；元素：页面中的所有标签都是元素
		// 节点：网页中所有内容都是节点（标签、属性、文本、注释）

		// 获取元素：
		// getElementById() 找不到返回null；注意script必须先有id的元素标签
		// 	返回值为元素对象
		// console.log(time)//返回标签元素
		// console.dir(time)//返回标签元素的属性和方法
		// getElementsByTagName()动态获取元素内容

		// var div = document.createElement('div');
		// document.body.appendChild(div);

		// var divs = document.getElementsByTagName('div');
		// console.log(divs);//1个
		// var div1 = document.createElement('div');
		// document.body.appendChild(div1);

		// console.log(divs);//2个

		// H5新增querySelector()，不区分class,id,name选择
		// 1.返回指定选择器的第一个对象
		// 2.querySelectorAll()返回指定选择器的所有对象
		// 3.querySelectorAll不是动态的

		// 1.获取body；属性可读写
		// document.body
		// 2.获取html
		// document.documentElement
		// 3.同一个页面多个html,只有一个document

		// innerText
		// 1.去除html标签
		// 2.去除空格和换行
		// 3.获取到标签时会自动删除标签

		// innerHTML:识别字符串里面的标签
		// 1.包含html标签
		// 2.包括空格和换行



		// 表单元素属性
		// 1.type
		// 2.value:表单内文字属性 非innerHTML
		// 3.selected:
		// 4.disabled
		// 5.checked
		// 表单样式属性
		// 1.element.style行内样式 驼峰命名 > 内联样式权重
		// 2.element.className内联样式

		// 表单全选
		// 排他思想
		// checked = true

		// 获取属性方式
		// 1.element.属性,不能获取自定义属性,不能获取变量表示的属性
		// 2.element.getAttribute('') 此类属性可自定义（data-index）等
		// 3.element.setAttribute('key',value)
		// 4.element.removeAttribute('key')
		// 5.H5规定自定义属性以'data-'开头
		// 6.data-index=2 data-time=20
		// H5新增获取自定义属性element.dataset.index,element.dataset.time;dataset是一个集合
		// element.dataset['index'],element.dataset['time']



		// 节点操作
		// 1.DOM API获取,逻辑性不强,兼容性好
		// 2.节点层次获取
		// parentNode离元素最近的父节点,如果找不到则返回null
		// childNodes子节点的集合NodeList,包括文本节点和标签节点(换行和空格为文本节点)
		// node.nodeType 1:元素节点 3:文本节点
		// children只返回标签节点(元素节点)HTMLCollection
		// firstChild包括文本节点
		// lastChild包括文本节点
		// firstElementChild只返回元素节点
		// lastElementChild只返回元素节点 IE9以上才支持
		// children[0] children[2]
		// 不能用children[-1]

		// 兄弟节点
		// nextSibling,previousSibling包括文本节点
		// nextElementSibling,previousElementSibling IE9以上才支持

		// 创建节点
		// document.createElement
		// node.appendChild//给父亲添加子节点document.body
		// node.insertBefore(li,指定子元素)//给父亲节点指定子元素前面添加兄弟元素

		// 删除节点
		// node.removeChild(node.children[0])

		// 复制节点
		// node.cloneNode()复制node节点并返回新的节点
		// node.cloneNode(false)不复制其中的内容或其他子节点
		// node.cloneNode(true)深拷贝



		// slice()//截取，返回新数组，原始数组无变化
		// splice()//删除，替换，返回被删除元素数组，改变原始数组
		// shift()//头部插入
		// unshift()//头部删除


		javascript的语言特性










		前端优化方案

		// document.documentElement.clientWidth = width + padding
		// document.documentElement.clientHeight = height + padding

		// window.innerWidth = width + padding + border + 纵向滚动条宽度
		// window.innerHeight = height + padding + border + 横向滚动条高度

		// window.outerWidth = width + padding + border + 纵向滚动条宽度
		// window.outerHeight = height + padding + border + 横向滚动条高度 + 工具条高度

		// offset返回本身的宽高 + padding + border + 滚动条
		// https://img-blog.csdn.net/20150606173925216?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHpkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center



		// css盒模型


		重绘与回流
		1）重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。
			比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。
			一次性操作：DOM/CSS

		虚拟DOM：
		1）非每次变更都更新DOM树
		2）用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中
			当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
			把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了
		3）Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。


		// 渲染机制与js关系，js赋值时的操作


		// MVC,MVVM
		MVC:
			view -> controller -> model
		MVVM:
			view -> vieModel <-> model
		// MVC小程序
		// mvvm框架Vue，双向数据绑定


		// flask


		// python基本特性


		// 前端书籍


		// 为什么喜欢前端


		// 剑指OFFER


		link,import区别
		1）link引入样式表，CSS同时加载
		2）import只能引入样式表，页面加载完毕后再加载
		不同的浏览器有不同的渲染引擎，Firefox浏览器为Gecko引擎，Safari为WebKit引擎，Chrome为Blink引擎。



		小程序
		1.目录结构
		/pages：/index /logs对应不同的页面
			index.js
				Page({
					data:{
						msg:'hello'
					},
					rotateEvent(){

					}
				})
			index.wxml//组件化开发
				<view>
					<text bindTap='rotate'> {{msg}} </text>
				</view>
			index.wxss//不用被引入，但是必须同名
				CSS样式
		/utils：util.js
		app.js//App({ onLaunch:function(){ }; globalData:{} })
		const app = getApp();
		Page({
			data:{

			},
			rotateEvent:function(){

			}
		})

		App({
			onLaunch:function(){

			},
			globalData:{

			}

		})
		app.json//项目结构配置
			{
				"pages":[
					"pages/index/index",
					"pages/logs/logs"
				],
				"window":{
					"backgroundTextStyle":"light",
					"navigationBarTextStyle":"black"
				}
			}
		app.wxss//全局样式
		project.config.json// 项目配置
			{
				"description":'项目配置文件',
				"setting":{
					"urlCheck":true,
					"es6":true
				},
				"libVersion":'1.9.91'
			}

		2.完美适配 rpx
			iphone6:1rpx = 1px = 0.5csspx
		3.框架
			mpvue(美团开发)Vue.js in mini program

			/build
			/config
			webpack及项目相关配置
			/dist
			/node_modules
			/src
				/datas
				/images
				/pages
					/index
						index.vue[wxml wxss]
						main.js
						main.json
					/logs
				/router
					router.js
						import Vue from 'vue'
						import VueRouter from 'vue-router'
						imprort List from '../pages/list/list.vue'
						Vue.use(VueRouter)
						let routes = [
							{
								path:'/list',
								component:List
							}
						]
						export default new VueRouter({
							routes
						})
				/store 
				app.json
				App.vue
				main.js
			/static
			index.html 
			package.json
			package.lock.json
			project.config.json
			README.md 
		4.Vue组件间通信方式
			1）父->子
			2）子->父
			3）隔代组件
			4）兄弟

			1）props
				一般属性 父->子
				函数属性 子->父
			2）vue自定义事件
				子->父
				father:
					<myComponent @eventName="callback">
				son:
					this.$emit("eventName",data)
			3）消息订阅与发布
				pubsub.js
				订阅：
					PubSub.subscribe('msg',function(msg,data){})
					//消息名，回调函数
				发布：
					PubSub.publish('msg',data)
					//消息名，data传递给回调函数
			4）vuex插件
				1）为Vue.js应用程序开发的状态管理的vue插件
				2）集中式管理vue多个组件共享的状态和后台获取的数据
				vue-components读取状态：
					$store.state 
					$store.dispatch()

			5）slot[通信的数据为带数据的标签]
				父->子：
					父组件解析好的标签传递给子组件

		5.MVVM实现原理
			Vue作为MVVM模式的实现库的2种技术
			1）模板解析
				实现页面的初始化显示
					大括号表达式
					指令解析
			2）数据绑定
				实现更新显示
					数据劫持
			new MVVM()
	Vue
	1.搭建
		vue init webpack demoName
		cd demoName
		npm run dev 
	2.目录
		/build[项目构建webpack相关代码]
		/config[配置目录，跨域，端口号等]
		/node_modules[npm的项目依赖模块]
		/src
			/assets[图片，logo]
			/components[组件文件]
			/router[路由文件]
			App.vue[项目入口文件]
				<template></template>
				 <script>
				 	export default {
				 		name:'App'
				 	}
				 </script>
				 <style></style>
			main.js[项目核心文件]
		/static
		index.html[首页入口文件]
		package.json
		package-lock.json
		README.md
	3.Vue中的<template>
		1）HTML <template> 元素是一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用 JavaScript 进行实例化。
		2）可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。
		3）单组件文件

虽然, 在加载页面的同时,解析器确实处理 <template>元素的内容，这样做只是确保这些内容是有效的; 然而,元素的内容不会被渲染。
	4.v-if v-show
		v-if create delete[切换开销，v-else-if,v-else]
		v-show display:none display:block[渲染开销]
	5.v-model
		实现表单value数据的双向绑定
	6.生命周期
	7.小程序生命周期/区别
	8.vue-loader
		允许加载.vue后缀，在配置文件中
		js可以写es6，style样式可以用less\sass等
	9.nextTick
		$nextTick是在下次DOM更新循环结束之后执行延迟回调，可以在回调中获取更新后的DOM
		1）视图层数据变化，但是DOM元素未更新
		2）VUE是异步更新，等同一事件循环中的所有数据变化完成之后，再统一进行视图更新
		3）因此console.log()打印之后才会进行视图更新
	10.vue路由
		
	11.$ref
		1）用在元素上，可以获取元素实例
		2）用在子组件上，可以使用子组件的所有方法
	12.vue加载顺序
		1）index.html
		2）main.js，引入app.vue，生成vue实例
		3）app.vue，全局组件，所有子组件的父组件
		4）index.js，路由
	13.父子组件的渲染顺序
		父组件先开始，子组件先结束
		父组件在两边，子组件在中间
		1）加载渲染过程
			父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
		2）子组件更新过程
			父beforeUpdate->子beforeUpdate->子updated->父updated
		3）父组件更新过程
			父beforeUpdate->父updated
		4）销毁过程
			父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

	14.axios与ajax区别
		1）axios
			底层使用node.js
			支持Promise
			客户端支持防止CSRF
			提供了并发的接口
		2）ajax
			针对MVC编程
			基于原声XHR开发
			需要引入整个jQuery
		3）fetch
			更加底层，提供丰富的API request。response
			脱离XHR
	12.ajax请求type

	13.http响应码
		200：请求成功
		300：重定向
		400：客户端参数/语义有误
		404：客户端请求资源未在服务器上
		405：客户端请求方法不被允许
		500：服务器不知道如何处理
		501：服务器不支持请求方法
		502：网关错误
		503：服务器维护/忙碌
		505：服务器不支持HTTP协议版本
	14.http请求头
		Accept
		Accept-Language
		Content-Language
		Last-Event-ID
		Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

		GET /cors HTTP/1.1
		Origin: http://api.bob.com
		Host: api.alice.com
		Accept-Language: en-US
		Connection: keep-alive
		User-Agent: Mozilla/5.0...
	15.http返回头
		Access-Control-Allow-Origin: http://api.bob.com
		Access-Control-Allow-Credentials: true
		Access-Control-Expose-Headers: FooBar
		Content-Type: text/html; charset=utf-8
	16.组件注册方式
		1）全局注册
		2）局部注册
	17.懒加载
		1）将资源的src放在其余属性中
		2）当图片将要出现在可视区域时，将src赋值为资源路径
	18.CSRF
		1）验证HTTP Referer字段
		HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。
	19.node.js
		基于Chrome V8引擎的JS运行环境
		1）事件驱动
		2）非阻塞
	20.get post区别

	21.操作系统的进程状态
		就绪  ->  执行  ->  阻塞  ->  就绪
		   进程调度   I/O请求	   I/O完成
	22.域名，跨域/一级域名，二级域名
	23.小程序生命周期
	24.vue生命周期
	25.router路由（Vue和小程序）
	26.restful
	27.MVC(flask) MVVM(vue)







		





	</script>
</body>
</html>